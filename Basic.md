# 基本

1.  クラスの継承を避ける

    多重継承は行えないため、特にライブラリとして提供する場合は`Activity`等の
    各アプリケーションで基底クラスを用意する可能性の高いクラスに対して
    サブクラス化を求めないようにする。

1.  スコープは小さく始める

    新しいクラス、メソッド、フィールドを追加する場合はまずprivateから検討する。
    必要になったときにアクセス可能な範囲を拡大することを検討する。
    
    ただし、フィールドとアクセサメソッド(getter/setter)しかなく
    アクセサメソッドも単にフィールドを返したり代入したりするだけのものならば
    フィールドをpublicにしても良い。
    (getter/setterのメンテナンスでエンバグしてしまう方がリスクである。)

1.  クラスフィールドを避ける

    アプリケーション全体で共有すべきデータであっても、staticはなるべく避ける。  
    そのようなデータはアプリケーションのライフサイクルに沿ってデータが管理されるよう、
    Applicationの継承クラスに持たせた方が良い。  
    いずれにしても、こうしたアプリ内でのグローバルなデータが多くなると
    アプリケーション全体の状態遷移が複雑になるため、
    そもそもこうしたデータを持つことを避けられないかどうかを検討する。

1.  ショートサーキット

    複数の条件を判定する場合、`||`, `&&`を使用して
    必要な部分だけを評価させるようにする(ショートサーキット)。  
    ビット演算(`|`, `&`)はビット演算が目的の場合にのみ使用する。  
    ショートサーキットを期待してビット演算子を利用するとバグに繋がる。

    悪い例:

    ```java
    public void save(List<Data> list) {
        if (list != null & list.size() > 0) {
            // listに要素がある場合にのみ処理をすることを期待。
            // listがnullの可能性を考慮してチェックしているように見えるが、
            // ビット演算のため必ず2つ目の式も評価される。
            // そのためlistがnullの場合でもsize()メソッドが呼び出され
            // クラッシュする
    ```

    良い例:

    ```java
    public void save(List<Data> list) {
        if (list != null && list.size() > 0) {
            // listがnullの場合はif文の条件式全体がfalseになるので
            // 2つ目の式は評価されない
    ```

1.  宣言と初期化

    ローカル変数は、使う直前に、初期値と共に宣言する。  

1.  ローカル変数は再利用しない

    同じような用途であっても、ある変数を複数の目的に使わないこと。  
    そもそも使い回しができるということは、
    その部分をメソッドとして抽出できる可能性もあるためリファクタリングを検討すること。

1.  比較の方向

    小＜大の方向に揃える。

1.  キャスト

    `instanceof`、もしくは`Object#getClass()`の比較によってキャストしても
    問題がないことを確認してからキャストすること。

1.  例外クラス

    安易に例外をスローしない。
    特に、利用側で意識されない可能性の高いRuntimeExceptionは思わぬところでのクラッシュを招く。
    スローする場合は、呼び出し元のどのような位置でキャッチされるべきものなのかについても
    設計する。
    また、例外クラスは、新たに作成する前にAndroid SDKに含まれているものが利用できるか
    どうかを検討する。

1.  メソッド引数の名前

    メソッドの引数は、読みやすいものにすること。  
    インスタンス変数へ代入するものは、接頭辞「m」を外して同名にすること。  
    
    悪い例:
    
    ```java
    void reset(int x_, int y_)  {
      x = x_; 
      y = y_;
    }
    void reset(int x, int y)  {
      this.x = x; 
      this.y = y;
    }
    ```

    良い例:

    ```java
    void reset(int x, int y)  { // 引数名を x_, y_ などとしない
      mX = x; // Androidではthis.を避ける
      mY = y;
    }
    ```

1.  拡張for文を使う

    繰り返し処理では拡張for文を使うこと。

    理由:

    * ループカウンタを設ける従来のfor文はループ内処理の可読性を落とす。
    * 従来のfor文では添字に与える番号を間違えるようなバグを埋め込む可能性がある。

1.  HashMap より SparseArray を使う

    特別な理由がなければ、`HashMap`よりも速度、メモリ効率の良い`SparseArray`を使う。

1.  文字列の必須チェックには TextUtils.isEmpty() を使う

    文字列のnullまたは空チェックには、`TextUtils.isEmpty()`を使用する。

1.  デフォルトで設定される InputFilter を無効にしない

    XMLで`android:maxLength`などを指定されると、
    暗黙的に`InputFilter`が設定される。
    独自の`InputFilter`を追加で設定する場合、`EditText#setInputFilters()`で
    直接設定してしまうと暗黙的に設定された`InputFilter`が消えてしまうことに
    注意する。

1.  具体的ケースが想定できるRuntimeExceptionはキャッチする

    入力された文字列(`String`)を`Integer`へ変換して失敗する時にスローされる
    `NumberFormatException`など、仕様上発生し得ることが分かっている場合は
    キャッチしておくこと。

1.  Exceptionを必ずキャッチする

    `RuntimeException`をスローしたままの部分がないか。
    Androidの場合はキャッチされていない例外はクラッシュに繋がるため、
    必要に応じて`catch(Exception e)`としてすべてキャッチして
    適切なエラー表示をするようにしても良い。

1.  一部のクラスには引数なしのデフォルトコンストラクタが必須

    `Fragment`など、フレームワークによりライフサイクルに合わせて自動的に
    インスタンスを再生成するようなクラスでは、引数なしの
    デフォルトコンストラクタを実装しておくことが必須。  
    Android SDKのクラスを継承したクラスで独自のコンストラクタを
    定義する場合は、その可能性に注意する。

1.  引数をチェックする

    privateメソッドで利用箇所が限られており、チェックしなくても
    必ず正常値が与えられると分かっている場合を除いて、
    引数が想定する範囲・形式であるかをチェックすること。  
    特にユーティリティ系のpublic staticなメソッドはあらゆる箇所から
    呼び出し可能なためチェック処理を入れる。

1.  nullチェックしていないオブジェクトに対するメソッド呼び出しを避ける

    nullでないことが明確に保証されている場合を除いて、
    nullチェックをしていないオブジェクトに対してメソッドを呼び出すことを
    避けること。

1.  ユーザ入力する項目については必ず入力チェックする

    `EditText`等でユーザが自由に入力する項目から得られた値は必ずチェックして
    利用すること。

1.  文字コードの変換ができない文字の存在を考慮する

    仕様上、アプリケーション内で文字コード変換を要する場合は
    変換できない文字が存在する可能性を考慮する。  
    特に、外部のAPI等とデータを送受信する場合は外部システムの仕様に合わせて
    利用可能な文字も制限される可能性があることに注意する。

1.  戻り値にnullなど予期しない値が入るケースを考慮する

    メソッドの戻り値を利用する際、有効な値以外が返ってくる可能性を考慮する。  
    例えば、オブジェクトを返すメソッドが異常値としてnullを返す場合、
    そのメソッドの呼び出し側で戻り値のnullをチェックせずにメソッドを
    呼び出すと`NullPointerException`が発生する。

    悪い例:

    ```java
    SomeData data = externalObject.doSomething();
    data.execute(); // dataがnullの場合にNullPointerExceptionが発生する
    ```

    良い例:

    ```java
    SomeData data = externalObject.doSomething();
    if (data != null) {
        data.execute();
    }
    ```

1.  elseのない分岐を作らない

    特定条件の場合のみメソッドを終了させる、といった場合を除いて
    else節のない分岐を作らないこと。  
    何らかの理由でifの条件を満たさずに処理が続行される場合を想定して、
    然るべきデフォルト処理を入れておく。

1.  elseやcatchで異常を無視しない

    異常値をハンドリングするelseやcatchブロックでは、
    最低限ログを出力すること。

1.  不要な処理を残さない

    デバッグ用途で一時的に作成したメソッドや、仕様変更前の処理など、
    使わなくなった処理を残さないこと。
    理由があって使わなくなったものをうっかり使ってしまわないようにするため。
    特に`public`なメソッドでは、利用されなくなったとしても
    IDEによる警告が出ないため、
    別のメンバーが誤って使ってしまうリスクが高まることに注意する。

1.  デフォルト値に頼らない

    タイムアウト等を明示的に設定する。
    特に、SDKに任せたデフォルト値になっていると
    SDKのバージョンにより動作が変わってしまう原因となる。

1.  フラグ値の取り扱いを合わせる

    処理フローを制御するものである可能性が高いため。

1.  finish()やstartActivity()では処理は終了しない

    Activityにて画面を終了させるために`finish()`を呼び出しても、
    同期処理で直ちに画面が終了されるわけではない。
    メソッドを終了させたいのであれば`return`を書くこと。
    同様に、次の画面を開始するために`startActivity()`を呼び出しても、
    直ちにそのメソッドが終了するわけではない。
    後続処理を実行したくない場合は`return`を書くこと。

    悪い例:

    ```java
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        Intent data = getIntent();
        if (data == null || data.hasExtra(Intent.EXTRA_TEXT)) {
            // このActivityで共有するコンテンツが指定されていないので
            // 終了させたい
            finish();
        }
        // 上のブロックを通っていても以下は実行される
        String text = data.getStringExtra(Intent.EXTRA_TEXT);
        :
    }
    ```

    良い例:

    ```java
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        Intent data = getIntent();
        if (data == null || data.hasExtra(Intent.EXTRA_TEXT)) {
            finish();
            return; // 後続処理は実行されない
        }
        String text = data.getStringExtra(Intent.EXTRA_TEXT);
        :
    }
    ```

1.  ハードウェア機能のサポートをチェックする

    API仕様上、対象のAPIレベルで用意されているAPIがあっても、
    ハードウェアがサポートしていない可能性がある。
    例えばカメラを利用する場合にその端末でサポートされている撮影画像サイズ
    を調べる`Camera.Parameters#getSupportedPictureSizes()`のように、
    `getSupported-`系のメソッドが用意されているものについては
    サポートされていることをチェックしてから利用すること。

1.  すべてのAPIが例外をスローすると想定する

    Android SDKのAPIが正常な結果を返すことを想定せず、例外がスローされると
    想定する。例外がスローされた場合にアプリのクラッシュ等の致命的な
    エラーにならないようにするため、どこにcatchを挿入するかを検討すること。

1.  メソッドの連続呼び出しに注意する

    メソッドの戻り値から直接メソッドを呼び出すような連鎖的な記述に注意する。
    戻り値がnullだった場合にNullPointerExceptionが発生するため。  
    nullチェックをしてから呼び出すか、結果の有無をチェックするメソッドを用意する。  

    悪い例:

    ```java
    if (getResultList().size() > 0) { // getResultList()はnull以外を返すのか？
    ```

    良い例:

    ```java
    List<Data> result = getResultList();
    if (result != null && result.size() > 0) {
    ```

    良い例:

    ```java
    // 上記のチェックをまとめたメソッドを用意する方が
    // 可読性も高まりチェック忘れも防げる
    if (hasResult()) {
    ```

    また、メソッドの連続呼び出しはリファクタリングが必要なサインでもある。  
    処理の実行主体自体を移せないかどうかについても検討する。

    例:

    ```java
    int result = data.getResult().getData().getCode();
    // このresultを使った処理は、このクラスで行なうべきだろうか？
    // 仲介するクラスは本当に必要か？
    // このクラスが多くのことをやりすぎていないか？
    // getData()メソッドを定義するクラスなど、連続呼び出しの間にある
    // クラスで処理できないのか検討
    ```
